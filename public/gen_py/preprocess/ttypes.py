#
# Autogenerated by Thrift Compiler (0.9.2)
#
# DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
#
#  options string: py
#

from thrift.Thrift import TType, TMessageType, TException, TApplicationException

from thrift.transport import TTransport
from thrift.protocol import TBinaryProtocol, TProtocol
try:
  from thrift.protocol import fastbinary
except:
  fastbinary = None



class net_video_in_conf:
  """
  Attributes:
   - ip
   - port
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'ip', None, None, ), # 1
    (2, TType.I32, 'port', None, None, ), # 2
  )

  def __init__(self, ip=None, port=None,):
    self.ip = ip
    self.port = port

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.ip = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.I32:
          self.port = iprot.readI32();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('net_video_in_conf')
    if self.ip is not None:
      oprot.writeFieldBegin('ip', TType.STRING, 1)
      oprot.writeString(self.ip)
      oprot.writeFieldEnd()
    if self.port is not None:
      oprot.writeFieldBegin('port', TType.I32, 2)
      oprot.writeI32(self.port)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.ip)
    value = (value * 31) ^ hash(self.port)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.items()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class net_video_channel:
  """
  Attributes:
   - device_id
   - channel_dev_id
   - channel_no
   - channel_name
   - connect_mode
   - face_db_no
  """

  thrift_spec = (
    None, # 0
    (1, TType.I32, 'device_id', None, None, ), # 1
    (2, TType.I32, 'channel_dev_id', None, None, ), # 2
    (3, TType.I32, 'channel_no', None, None, ), # 3
    (4, TType.STRING, 'channel_name', None, None, ), # 4
    (5, TType.I32, 'connect_mode', None, None, ), # 5
    (6, TType.LIST, 'face_db_no', (TType.I32,None), None, ), # 6
  )

  def __init__(self, device_id=None, channel_dev_id=None, channel_no=None, channel_name=None, connect_mode=None, face_db_no=None,):
    self.device_id = device_id
    self.channel_dev_id = channel_dev_id
    self.channel_no = channel_no
    self.channel_name = channel_name
    self.connect_mode = connect_mode
    self.face_db_no = face_db_no

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I32:
          self.device_id = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.I32:
          self.channel_dev_id = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.I32:
          self.channel_no = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.STRING:
          self.channel_name = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 5:
        if ftype == TType.I32:
          self.connect_mode = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 6:
        if ftype == TType.LIST:
          self.face_db_no = []
          (_etype3, _size0) = iprot.readListBegin()
          for _i4 in range(_size0):
            _elem5 = iprot.readI32();
            self.face_db_no.append(_elem5)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('net_video_channel')
    if self.device_id is not None:
      oprot.writeFieldBegin('device_id', TType.I32, 1)
      oprot.writeI32(self.device_id)
      oprot.writeFieldEnd()
    if self.channel_dev_id is not None:
      oprot.writeFieldBegin('channel_dev_id', TType.I32, 2)
      oprot.writeI32(self.channel_dev_id)
      oprot.writeFieldEnd()
    if self.channel_no is not None:
      oprot.writeFieldBegin('channel_no', TType.I32, 3)
      oprot.writeI32(self.channel_no)
      oprot.writeFieldEnd()
    if self.channel_name is not None:
      oprot.writeFieldBegin('channel_name', TType.STRING, 4)
      oprot.writeString(self.channel_name)
      oprot.writeFieldEnd()
    if self.connect_mode is not None:
      oprot.writeFieldBegin('connect_mode', TType.I32, 5)
      oprot.writeI32(self.connect_mode)
      oprot.writeFieldEnd()
    if self.face_db_no is not None:
      oprot.writeFieldBegin('face_db_no', TType.LIST, 6)
      oprot.writeListBegin(TType.I32, len(self.face_db_no))
      for iter6 in self.face_db_no:
        oprot.writeI32(iter6)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.device_id)
    value = (value * 31) ^ hash(self.channel_dev_id)
    value = (value * 31) ^ hash(self.channel_no)
    value = (value * 31) ^ hash(self.channel_name)
    value = (value * 31) ^ hash(self.connect_mode)
    value = (value * 31) ^ hash(self.face_db_no)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.items()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class net_video_host:
  """
  Attributes:
   - msg_type
   - type
   - device_id
   - ip
   - port
   - user
   - pwd
   - channels
  """

  thrift_spec = (
    None, # 0
    (1, TType.I32, 'msg_type', None, None, ), # 1
    (2, TType.I32, 'type', None, None, ), # 2
    (3, TType.I32, 'device_id', None, None, ), # 3
    (4, TType.STRING, 'ip', None, None, ), # 4
    (5, TType.I32, 'port', None, None, ), # 5
    (6, TType.STRING, 'user', None, None, ), # 6
    (7, TType.STRING, 'pwd', None, None, ), # 7
    (8, TType.LIST, 'channels', (TType.STRUCT,(net_video_channel, net_video_channel.thrift_spec)), None, ), # 8
  )

  def __init__(self, msg_type=None, type=None, device_id=None, ip=None, port=None, user=None, pwd=None, channels=None,):
    self.msg_type = msg_type
    self.type = type
    self.device_id = device_id
    self.ip = ip
    self.port = port
    self.user = user
    self.pwd = pwd
    self.channels = channels

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I32:
          self.msg_type = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.I32:
          self.type = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.I32:
          self.device_id = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.STRING:
          self.ip = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 5:
        if ftype == TType.I32:
          self.port = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 6:
        if ftype == TType.STRING:
          self.user = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 7:
        if ftype == TType.STRING:
          self.pwd = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 8:
        if ftype == TType.LIST:
          self.channels = []
          (_etype10, _size7) = iprot.readListBegin()
          for _i11 in range(_size7):
            _elem12 = net_video_channel()
            _elem12.read(iprot)
            self.channels.append(_elem12)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('net_video_host')
    if self.msg_type is not None:
      oprot.writeFieldBegin('msg_type', TType.I32, 1)
      oprot.writeI32(self.msg_type)
      oprot.writeFieldEnd()
    if self.type is not None:
      oprot.writeFieldBegin('type', TType.I32, 2)
      oprot.writeI32(self.type)
      oprot.writeFieldEnd()
    if self.device_id is not None:
      oprot.writeFieldBegin('device_id', TType.I32, 3)
      oprot.writeI32(self.device_id)
      oprot.writeFieldEnd()
    if self.ip is not None:
      oprot.writeFieldBegin('ip', TType.STRING, 4)
      oprot.writeString(self.ip)
      oprot.writeFieldEnd()
    if self.port is not None:
      oprot.writeFieldBegin('port', TType.I32, 5)
      oprot.writeI32(self.port)
      oprot.writeFieldEnd()
    if self.user is not None:
      oprot.writeFieldBegin('user', TType.STRING, 6)
      oprot.writeString(self.user)
      oprot.writeFieldEnd()
    if self.pwd is not None:
      oprot.writeFieldBegin('pwd', TType.STRING, 7)
      oprot.writeString(self.pwd)
      oprot.writeFieldEnd()
    if self.channels is not None:
      oprot.writeFieldBegin('channels', TType.LIST, 8)
      oprot.writeListBegin(TType.STRUCT, len(self.channels))
      for iter13 in self.channels:
        iter13.write(oprot)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.msg_type)
    value = (value * 31) ^ hash(self.type)
    value = (value * 31) ^ hash(self.device_id)
    value = (value * 31) ^ hash(self.ip)
    value = (value * 31) ^ hash(self.port)
    value = (value * 31) ^ hash(self.user)
    value = (value * 31) ^ hash(self.pwd)
    value = (value * 31) ^ hash(self.channels)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.items()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class net_video_conf:
  """
  Attributes:
   - hosts
   - match_ip
   - match_port
   - cap_interval
   - cap_type
   - success_flag
   - err_msg
  """

  thrift_spec = (
    None, # 0
    (1, TType.LIST, 'hosts', (TType.STRUCT,(net_video_host, net_video_host.thrift_spec)), None, ), # 1
    (2, TType.STRING, 'match_ip', None, None, ), # 2
    (3, TType.I32, 'match_port', None, None, ), # 3
    (4, TType.I32, 'cap_interval', None, None, ), # 4
    (5, TType.I32, 'cap_type', None, None, ), # 5
    (6, TType.I32, 'success_flag', None, None, ), # 6
    (7, TType.STRING, 'err_msg', None, None, ), # 7
  )

  def __init__(self, hosts=None, match_ip=None, match_port=None, cap_interval=None, cap_type=None, success_flag=None, err_msg=None,):
    self.hosts = hosts
    self.match_ip = match_ip
    self.match_port = match_port
    self.cap_interval = cap_interval
    self.cap_type = cap_type
    self.success_flag = success_flag
    self.err_msg = err_msg

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.LIST:
          self.hosts = []
          (_etype17, _size14) = iprot.readListBegin()
          for _i18 in range(_size14):
            _elem19 = net_video_host()
            _elem19.read(iprot)
            self.hosts.append(_elem19)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRING:
          self.match_ip = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.I32:
          self.match_port = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.I32:
          self.cap_interval = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 5:
        if ftype == TType.I32:
          self.cap_type = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 6:
        if ftype == TType.I32:
          self.success_flag = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 7:
        if ftype == TType.STRING:
          self.err_msg = iprot.readString();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('net_video_conf')
    if self.hosts is not None:
      oprot.writeFieldBegin('hosts', TType.LIST, 1)
      oprot.writeListBegin(TType.STRUCT, len(self.hosts))
      for iter20 in self.hosts:
        iter20.write(oprot)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    if self.match_ip is not None:
      oprot.writeFieldBegin('match_ip', TType.STRING, 2)
      oprot.writeString(self.match_ip)
      oprot.writeFieldEnd()
    if self.match_port is not None:
      oprot.writeFieldBegin('match_port', TType.I32, 3)
      oprot.writeI32(self.match_port)
      oprot.writeFieldEnd()
    if self.cap_interval is not None:
      oprot.writeFieldBegin('cap_interval', TType.I32, 4)
      oprot.writeI32(self.cap_interval)
      oprot.writeFieldEnd()
    if self.cap_type is not None:
      oprot.writeFieldBegin('cap_type', TType.I32, 5)
      oprot.writeI32(self.cap_type)
      oprot.writeFieldEnd()
    if self.success_flag is not None:
      oprot.writeFieldBegin('success_flag', TType.I32, 6)
      oprot.writeI32(self.success_flag)
      oprot.writeFieldEnd()
    if self.err_msg is not None:
      oprot.writeFieldBegin('err_msg', TType.STRING, 7)
      oprot.writeString(self.err_msg)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.hosts)
    value = (value * 31) ^ hash(self.match_ip)
    value = (value * 31) ^ hash(self.match_port)
    value = (value * 31) ^ hash(self.cap_interval)
    value = (value * 31) ^ hash(self.cap_type)
    value = (value * 31) ^ hash(self.success_flag)
    value = (value * 31) ^ hash(self.err_msg)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.items()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class match_conf:
  """
  Attributes:
   - msg_type
   - match_ip
   - match_port
  """

  thrift_spec = (
    None, # 0
    (1, TType.I32, 'msg_type', None, None, ), # 1
    (2, TType.STRING, 'match_ip', None, None, ), # 2
    (3, TType.I32, 'match_port', None, None, ), # 3
  )

  def __init__(self, msg_type=None, match_ip=None, match_port=None,):
    self.msg_type = msg_type
    self.match_ip = match_ip
    self.match_port = match_port

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I32:
          self.msg_type = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRING:
          self.match_ip = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.I32:
          self.match_port = iprot.readI32();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('match_conf')
    if self.msg_type is not None:
      oprot.writeFieldBegin('msg_type', TType.I32, 1)
      oprot.writeI32(self.msg_type)
      oprot.writeFieldEnd()
    if self.match_ip is not None:
      oprot.writeFieldBegin('match_ip', TType.STRING, 2)
      oprot.writeString(self.match_ip)
      oprot.writeFieldEnd()
    if self.match_port is not None:
      oprot.writeFieldBegin('match_port', TType.I32, 3)
      oprot.writeI32(self.match_port)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.msg_type)
    value = (value * 31) ^ hash(self.match_ip)
    value = (value * 31) ^ hash(self.match_port)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.items()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class ClientInMsgVideoDetect:
  """
  Attributes:
   - msg_type
   - c_id
   - uuid
   - pic
   - pic_size
   - max_face
   - face_db_list
  """

  thrift_spec = (
    None, # 0
    (1, TType.I32, 'msg_type', None, None, ), # 1
    (2, TType.I32, 'c_id', None, None, ), # 2
    (3, TType.STRING, 'uuid', None, None, ), # 3
    (4, TType.STRING, 'pic', None, None, ), # 4
    (5, TType.I32, 'pic_size', None, None, ), # 5
    (6, TType.I32, 'max_face', None, None, ), # 6
    (7, TType.LIST, 'face_db_list', (TType.I32,None), None, ), # 7
  )

  def __init__(self, msg_type=None, c_id=None, uuid=None, pic=None, pic_size=None, max_face=None, face_db_list=None,):
    self.msg_type = msg_type
    self.c_id = c_id
    self.uuid = uuid
    self.pic = pic
    self.pic_size = pic_size
    self.max_face = max_face
    self.face_db_list = face_db_list

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I32:
          self.msg_type = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.I32:
          self.c_id = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRING:
          self.uuid = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.STRING:
          self.pic = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 5:
        if ftype == TType.I32:
          self.pic_size = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 6:
        if ftype == TType.I32:
          self.max_face = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 7:
        if ftype == TType.LIST:
          self.face_db_list = []
          (_etype24, _size21) = iprot.readListBegin()
          for _i25 in range(_size21):
            _elem26 = iprot.readI32();
            self.face_db_list.append(_elem26)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('ClientInMsgVideoDetect')
    if self.msg_type is not None:
      oprot.writeFieldBegin('msg_type', TType.I32, 1)
      oprot.writeI32(self.msg_type)
      oprot.writeFieldEnd()
    if self.c_id is not None:
      oprot.writeFieldBegin('c_id', TType.I32, 2)
      oprot.writeI32(self.c_id)
      oprot.writeFieldEnd()
    if self.uuid is not None:
      oprot.writeFieldBegin('uuid', TType.STRING, 3)
      oprot.writeString(self.uuid)
      oprot.writeFieldEnd()
    if self.pic is not None:
      oprot.writeFieldBegin('pic', TType.STRING, 4)
      oprot.writeString(self.pic)
      oprot.writeFieldEnd()
    if self.pic_size is not None:
      oprot.writeFieldBegin('pic_size', TType.I32, 5)
      oprot.writeI32(self.pic_size)
      oprot.writeFieldEnd()
    if self.max_face is not None:
      oprot.writeFieldBegin('max_face', TType.I32, 6)
      oprot.writeI32(self.max_face)
      oprot.writeFieldEnd()
    if self.face_db_list is not None:
      oprot.writeFieldBegin('face_db_list', TType.LIST, 7)
      oprot.writeListBegin(TType.I32, len(self.face_db_list))
      for iter27 in self.face_db_list:
        oprot.writeI32(iter27)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.msg_type)
    value = (value * 31) ^ hash(self.c_id)
    value = (value * 31) ^ hash(self.uuid)
    value = (value * 31) ^ hash(self.pic)
    value = (value * 31) ^ hash(self.pic_size)
    value = (value * 31) ^ hash(self.max_face)
    value = (value * 31) ^ hash(self.face_db_list)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.items()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)
